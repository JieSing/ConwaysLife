{ ---------------------Conway's life ------------------------------- }
{ -------------------By Harry and Jie Sing-------------------------- }
{ ------------------requires rnd file------------------------------- }


{ ---------------- Define constants and variables------------------- }
10 constant height { Changing height and width will change the cell map's dimensions }
10 constant width
variable length
height width * length ! { Length is the total amount of numbers }


{ --------------------Create arrays-------------------------------- }
create current_array length chars allot { 2 arrays are required }
create temp_array length chars allot

{ Set the elements in both arrays to 0 }
: reset_array ( -- ) current_array length 0 fill ; 
: reset_temp_array ( -- ) temp_array length 0 fill ;
reset_array
reset_temp_array 


{ ---------------Function to clear the stack----------------------- }
: clearstack ( -- ) depth 0 = invert if depth 0 do i drop drop loop then ;


{ ----------Words to change and read the array elements------------ }
{ Words for current_arrray }
: Array_@ ( n1 n2 -- n3 ) width * + current_array + c@ ; { Lets you read element x y of current_array }
: Array_! ( n1 n2 n3 -- ) width * + current_array + c! ; { Changes the value of element x y in current_array to n1 }
: show_current_array ( -- ) cr width 0 do height 0 do i j Array_@ 5 u.r loop cr loop ; { prints the contents of current_array }

{ Words for temp_array }
: Array_temp_@ ( n1 n2 -- n3 ) width * + temp_array + c@ ; { Lets you read element x y of temp_array }
: Array_temp_! ( n1 n2 n3 -- ) width * + temp_array + c! ; { Changes the value of element x y to n1 }
: Array_temp_add ( n1 n2 n3 -- ) over over Array_temp_@ 3 pick + rot rot Array_temp_! drop ; { Adds n1 to element x y }
: show_temp_array ( -- ) cr width 0 do height 0 do i j Array_temp_@ 5 u.r loop cr loop ; { prints the contents of temp_array }


{ --------Read a cell map pattern from a textfile------------------ }
{ Read the contents of the textfile and put it on the stack }
: read_textfile ( -- n n1 n2 ... )
  s" ./glider.txt" { Give the text file location }
  ['] included depth 1- >r execute depth r> - 2 + ; { Write contents onto the stack }

{ Write the stack into the array }
: Write_into_array ( n n1 n2 ... -- )
length @ <> abort" Unexpected amount of numbers" { Reject if more numbers than elements in the array }
current_array length 0 fill { clear the previous values in current_array }
length @ 0 do length @ 1 - i - current_array + c! loop ; { Write the stack into current_array }

{ Reads a known pattern from a text file into an array }
: Known_pattern clearstack read_textfile write_into_array ;


{ --------------------------------------------------------------------- }
{ --Changes the values on the cell map caused by adding an alive cell-- }

{ Iterate over all elements surronding the alive cell }
: centre ( n1 n2 -- n1 n2 ) over over 1 rot rot Array_temp_add ;

: bottom ( n1 n2 -- n1 n2 ) over over dup height 1 - = if drop -1 then
1 + 2 rot rot Array_temp_add ;

: bottom_right ( n1 n2 -- n1 n2 ) over over dup height 1 - = if drop -1 then
swap dup width 1 - = if drop -1 then swap
swap 1 + swap 1 + 2 rot rot Array_temp_add ;

: right ( n1 n2 -- n1 n2 ) over over swap dup width 1 - = if drop -1 then swap
swap 1 + swap 2 rot rot Array_temp_add ;

: top_right ( n1 n2 -- n1 n2 ) over over dup 0 = if drop height then
swap dup width 1 - = if drop -1 then swap
swap 1 + swap 1 - 2 rot rot Array_temp_add ;

: top ( n1 n2 -- n1 n2 ) over over dup 0 = if drop height then
1 - 2 rot rot Array_temp_add ;

: top_left ( n1 n2 -- n1 n2 ) over over dup 0 = if drop height then
swap dup 0 = if drop width then swap
swap 1 - swap 1 - 2 rot rot Array_temp_add ;

: left ( n1 n2 -- n1 n2 ) over over swap dup 0 = if drop width then swap
swap 1 - swap 2 rot rot Array_temp_add ;

: bottom_left ( n1 n2 -- n1 n2 ) dup height 1 - = if drop -1 then
swap dup 0 = if drop width then swap
swap 1 - swap 1 + 2 rot rot Array_temp_add ;

{ Increase the values of cell and its adjacent cells to represent an alive cell }
: Add_alive_cell ( n1 n2 -- ) centre bottom bottom_right right top_right top top_left left bottom_left ;


{ ------------------------------------------------------------------------------- }
{ ----Finds the next generation of current_array and writes it in temp_array----- }
: next_gen ( -- ) width 0 do height 0 do
i j Array_@
case dup { cells with value 5,6,7 will be alive in the next generation }
5 of i j Add_alive_cell drop endof { Adds an alive cell in position x y in the temp_array }
6 of i j Add_alive_cell drop endof
7 of i j Add_alive_cell drop endof
drop endcase loop loop ;


{ --------Swaps the values of current_array with the values of temp_array------- }
: swap_array ( -- ) width 0 do height 0 do i j Array_temp_@ i j Array_! loop loop ;


{ -------Generates a random pattern on the cell map ( requires rnd )-------------- }
: random_pattern ( -- ) reset_temp_array width 0 do height 0 do 
2 rnd 1 = if i j Add_alive_cell then loop loop { adds an alive cell to the temp array when a 1 is generated }
swap_array reset_temp_array ; { swaps the arrays around }


{ ------Endlessly iterates through next generations of Conway's life-------------- }
{ -------Before using please run known_pattern or random_pattern------------------ }
: Endless_iterate begin show_current_array next_gen swap_array reset_temp_array again ;